if (!process.env.NODE_ENV) {
  require("dotenv").config({
    path: "./config/config.env",
  });
}

const { TELEGRAM_BOT_TOKEN, BOT_USERNAME, BOT_NAME } = process.env;

const ADMINS = [471468236];

// const needle = require("needle");
const TelegramAPI = require("node-telegram-bot-api");
// const TikTokScraper = require("tiktok-scraper");
// const ytdl = require("ytdl-core");
// const fs = require("fs")
const redis = require("./helpers/redis");

// const db = {
//   downloaders: {
//     // 471468236: new Date(),
//   },
// };

const bot = new TelegramAPI(TELEGRAM_BOT_TOKEN, {
  polling: true,
});

bot.setMyCommands([
  { command: "/start", description: "–ó–∞–ø—É—Å—Ç–∏—Ç—å –±–æ—Ç–∞ / Launch the Bot" },
  { command: "/help", description: "–ü–æ–º–æ—â—å —Å –±–æ—Ç–æ–º / Bot info" },
]);

bot.onText(/\/say (.+)/, (msg, match) => {
  const chatId = msg.chat.id;

  const [, phrase] = match;
  // console.log(phrase)

  bot.sendMessage(chatId, phrase);
});

const {
  // getNoWatermarkUrl,
  getVideoByUrl,
} = require("./handlers/tiktok");
const needle = require("needle");
// const handlers = require("./handlers")(bot);

// bot.onText(handlers.tiktok.regex, handlers.tiktok.callback);

const videoRegex =
  /https?:\/\/www.tiktok.com\/@([\D\d]+)\/video\/(\d+)|https?:\/\/vm.tiktok.com\/([A-Z]+)/i;

let ttDownloadWaitMsg;

const ttCallback = async (msg, match) => {
  const chatId = msg.chat.id;
  const redisChatKey = `{chats.paused}${chatId}`;

  const [, username, videoId, mobileId] = match;
  // return console.log(match);

  const videoUrl =
    "https://" +
    (mobileId
      ? `vm.tiktok.com/${mobileId}`
      : `www.tiktok.com/@${username}/video/${videoId}`);

  // return console.log(await getVideo(videoUrl));

  const VIDEO_DOWNLOAD_TIMEOUT = 60; // 1 –º–∏–Ω
  const ONE_THOUSAND = 1e3; // –ß–∏—Å–ª–æ 1000

  const isDownloadAvailable = await (async () => {
    const reply = await redis.get(redisChatKey);

    if (reply) {
      return {
        ok: false,
        claimed: new Date(reply),
      };
    } else {
      return {
        ok: true,
        claimed: null,
      };
    }
  })();

  const nowTimestamp = new Date().getTime();
  const claimDelay =
    !isDownloadAvailable.ok && isDownloadAvailable.claimed.getTime();

  if (
    !ADMINS.includes(chatId) &&
    !isDownloadAvailable.ok &&
    nowTimestamp < claimDelay + VIDEO_DOWNLOAD_TIMEOUT * ONE_THOUSAND
  ) {
    return bot.sendMessage(
      chatId,
      `–ü–æ–¥–æ–∂–¥–∏—Ç–µ <b>${parseFloat(
        (claimDelay + VIDEO_DOWNLOAD_TIMEOUT * ONE_THOUSAND - nowTimestamp) /
          ONE_THOUSAND
      ).toFixed(
        1
      )}</b> —Å–µ–∫. ‚Äî –∏ —Å–º–æ–∂–µ—Ç–µ <b><em>–¥–∞–ª—å—à–µ —Å–∫–∞—á–∏–≤–∞—Ç—å –≤–∏–¥–µ–æ!</em></b>`,
      {
        parse_mode: "HTML",
      }
    );
  }

  console.time("ttDownload");

  // return console.log(msg.chat);
  // console.log(videoUrl);

  // return await mainGetNoWatermarkUrl();

  if (!ttDownloadWaitMsg) {
    ttDownloadWaitMsg = await bot.sendMessage(chatId, `–í–∏–¥–µ–æ –∑–∞–≥—Ä—É–∂–∞–µ—Ç—Å—è...`);
  }

  let noWaterMarkUrl;

  try {
    noWaterMarkUrl = await getVideoByUrl(videoUrl);
  } catch (err) {
    console.error(err.message);
  }

  if (!noWaterMarkUrl) {
    // –ï—Å–ª–∏ —Å—Å—ã–ª–∫–∞ —Å —Å–∞–π—Ç–∞ –Ω–µ –ø—Ä–∏—à–ª–∞ - –ø–æ–¥–æ–∂–¥–∞—Ç—å —Å–µ–∫—É–Ω–¥—É –∏ –ø–æ–≤—Ç–æ—Ä–∏—Ç—å —Å–Ω–æ–≤–∞
    // bot.deleteMessage(chatId, waitMsg.message_id);
    // return setTimeout(ttCallback.bind(null, msg, match), 500);
    return bot.sendMessage(chatId, `–ù–µ —É–¥–∞–ª–æ—Å—å —Å–∫–∞—á–∞—Ç—å —É–∫–∞–∑–∞–Ω–Ω—ã–π –í–∞–º–∏ —Ä–µ—Å—É—Ä—Å`);
    // return ttCallback(msg, match);
  }

  // console.log(noWaterMarkUrl)
  // console.timeEnd("ttDownload");

  await redis.setex(redisChatKey, VIDEO_DOWNLOAD_TIMEOUT, new Date());

  try {
    console.log(noWaterMarkUrl);

    await bot.sendMediaGroup(chatId, [
      {
        type: "video",
        media: noWaterMarkUrl,
        caption: `${videoUrl}\n\n–í–∏–¥–µ–æ —Å–∫–∞—á–∞–Ω–æ –ø—Ä–∏ –ø–æ–¥–¥–µ—Ä–∂–∫–µ ${BOT_USERNAME}`,
      },
    ]);
    // await bot.sendVideo(chatId, noWaterMarkUrl);
  } catch (err) {
    const noWaterMarkBuffer = await needle("get", noWaterMarkUrl);
    // console.log(noWaterMarkBuffer.body);

    console.error(
      "Error while sending media: ",
      err.message,
      "Sending buffer instead"
    );
    await bot.sendVideo(chatId, noWaterMarkBuffer.body);
  }

  console.timeEnd("ttDownload");

  if (ttDownloadWaitMsg) {
    bot.deleteMessage(chatId, ttDownloadWaitMsg.message_id);
    ttDownloadWaitMsg = null;
  }

  // const videoMeta = await TikTokScraper.getVideoMeta(videoUrl, {
  // 	noWaterMark: true,
  // 	hdVideo: true,
  // 	headers
  // });
  // console.log(videoMeta)

  // try {

  // } catch (error) {
  //   console.log(error.message);
  //   return bot.sendMessage(
  //     chatId,
  //     `–ü—Ä–∏ –∑–∞–≥—Ä—É–∑–∫–µ –≤–∏–¥–µ–æ –ø—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞\n–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–≤—Ç–æ—Ä–∏—Ç–µ –ø–æ–ø—ã—Ç–∫—É –µ—â—ë —Ä–∞–∑!`
  //   );
  // }

  // bot.sendMessage(chatId, phrase)
};

// bot.onText(videoRegex, ttCallback);

// bot.onText(
//   /https?:\/\/www.youtube.com\/watch\?v=[a-zA-Z-0-9_]+/gi,
//   async (msg, match) => {
//     const chatId = msg.chat.id;
//     const videoUrl = match[0];

//     // return console.log(videoUrl)

//     const waitMessage = await bot.sendMessage(
//       chatId,
//       "–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –ø–æ–¥–æ–∂–¥–∏—Ç–µ..."
//     );

//     const info = await ytdl.getInfo(videoUrl);
//     const format = ytdl.chooseFormat(info.formats, {
//       quality: ["137", "136", "135"],
//       filter: format => format.container === "mp4",
//     });

//     // return console.log(format)

//     const readableStream = await ytdl.downloadFromInfo(info, { format });

//     const videoBuffer = await new fetch.Response(readableStream).buffer();

//     // return console.log(videoBuffer)

//     try {
//       bot.sendVideo(chatId, videoBuffer);
//       bot.deleteMessage(chatId, waitMessage.message_id);
//     } catch (err) {
//       console.error(err.message);
//     }
//   }
// );

bot.on("callback_query", async msg => {
  const chatId = msg.message.chat.id;
  const { data } = msg;

  if (data === "/tt") {
    bot.sendMessage(
      chatId,
      "–í—Å—Ç–∞–≤—å—Ç–µ —Å—Å—ã–ª–∫—É –ª—é–±–æ–≥–æ –≤–∏–¥–µ–æ –∏–∑ TikTok –∏ —è –ø—Ä–∏—à–ª—é —Ç–µ–±–µ –æ—Ä–∏–≥–∏–Ω–∞–ª *–±–µ–∑ –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞!*",
      {
        parse_mode: "Markdown",
      }
    );
  }
});

bot.on("message", msg => {
  const { id: chatId, first_name, last_name } = msg.chat;

  // console.log(msg);

  const match = msg.text.match(videoRegex);

  // console.log(match);
  if (match) {
    return ttCallback(msg, match);
  }

  if (msg.text.match(/\/start/)) {
    return bot.sendMessage(
      chatId,
      `–î–æ–±—Ä–æ –ø–æ–∂–∞–ª–æ–≤–∞—Ç—å, ${first_name} ${last_name}!`,
      {
        reply_markup: {
          inline_keyboard: [
            [
              {
                text: "üé¨ –°–∫–∞—á–∞—Ç—å –≤–∏–¥–µ–æ –∏–∑ TikTok –±–µ–∑ –≤–æ–¥—è–Ω–æ–≥–æ –∑–Ω–∞–∫–∞",
                callback_data: "/tt",
              },
            ],
          ],
        },
      }
    );
  } else if (msg.text.match(/\/help/)) {
    return bot.sendMessage(
      chatId,
      `–ü—Ä–∏–≤–µ—Ç. –¢–µ–±–µ –Ω—É–∂–Ω–∞ –ø–æ–º–æ—â—å?\n\n–ú–µ–Ω—è –∑–æ–≤—É—Ç *${BOT_NAME}.*\n\n–Ø —É–º–µ—é —Å–∫–∞—á–∏–≤–∞—Ç—å –≤–∏–¥–µ–æ –∏–∑ TikTok.
      `,
      {
        parse_mode: "Markdown",
      }
    );
  }

  return bot.sendMessage(
    chatId,
    `–Ø –Ω–µ —Å–æ–≤—Å–µ–º —Ç–µ–±—è –ø–æ–Ω—è–ª...\n\n–ú–æ–∂–µ—Ç –æ—Ç–ø—Ä–∞–≤–∏—à—å —Å—Å—ã–ª–∫—É –Ω–∞ –≤–∏–¥–µ–æ?`
  );
});

bot.on("polling_error", err => {
  console.error(err);
});
